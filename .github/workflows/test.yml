# GitHub Actions ì›Œí¬í”Œë¡œìš° ì´ë¦„
name: Deploy Infrastructure and Application with Terraform

# ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì¡°ê±´: ìˆ˜ë™ ì‹¤í–‰ (workflow_dispatch)
on:
  workflow_dispatch:

# ì›Œí¬í”Œë¡œìš° ì „ì²´ì—ì„œ ì‚¬ìš©í•  í™˜ê²½ ë³€ìˆ˜
env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REGISTRY: ${{ secrets.ECR_REPOSITORY_URI }}

# ì›Œí¬í”Œë¡œìš° ì‘ì—…(Jobs) ì •ì˜
jobs:
  # ì¸í”„ë¼ ë°°í¬, DB ì„¤ì •, ì–´í”Œë¦¬ì¼€ì´ì…˜ ë°°í¬ë¥¼ ëª¨ë‘ ìˆ˜í–‰í•˜ëŠ” ë‹¨ì¼ ì‘ì—…
  deploy-and-configure:
    name: "Deploy Infra, Configure DB, and Deploy App"
    runs-on: ubuntu-latest
    # ì´ ì‘ì—…ì— í•„ìš”í•œ ê¶Œí•œ ì„¤ì •
    permissions:
      id-token: write   # AWS OIDC ì¸ì¦ ì‹œ í•„ìš”
      contents: read    # ì½”ë“œ ì²´í¬ì•„ì›ƒ ì‹œ í•„ìš”

    steps:
      # --- 1. Terraformìœ¼ë¡œ ì¸í”„ë¼ ë°°í¬ ---

      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.6

      - name: Create terraform.tfvars
        run: |
          mkdir -p terraform
          cat <<EOF > terraform/terraform.tfvars
          rds_config = {
            db_name     = "${{ secrets.PHOTOPRISM_DATABASE_NAME }}"
            db_user     = "${{ secrets.PHOTOPRISM_DATABASE_USER }}"
            db_password = "${{ secrets.PHOTOPRISM_DATABASE_PASSWORD }}"
          }
          s3_config = {
            bucket_name = "${{ secrets.PHOTOPRISM_S3_BUCKET }}"
          }
          EOF

      - name: Terraform Init
        working-directory: terraform
        run: terraform init -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" -backend-config="key=terraform/infra.tfstate" -backend-config="region=${{ secrets.AWS_REGION }}"
        
      - name: Terraform Validate
        working-directory: terraform
        run: terraform validate

      - name: Terraform Plan (Public RDS)
        working-directory: terraform
        run: terraform plan -var-file="terraform.tfvars" -var="rds_publicly_accessible=true" -input=false

      - name: Terraform Apply (Public RDS)
        working-directory: terraform
        run: terraform apply -var-file="terraform.tfvars" -var="rds_publicly_accessible=true" -auto-approve -input=false

      # --- 2. Terraform ê²°ê³¼ê°’ì„ í™˜ê²½ ë³€ìˆ˜ë¡œ ì„¤ì • ---

      - name: Export Terraform Outputs to Environment
        id: tf_outputs
        working-directory: terraform
        run: |
          echo "ğŸ“¤ Running terraform output"

          RDS_ENDPOINT=$(terraform output -raw rds_endpoint | sed 's/^.*output -raw rds_endpoint//' | sed 's/:3306//' | sed 's/::debug::.*//' | tr -d '\n' | xargs)
          S3_BUCKET=$(terraform output -raw my_bucket_name | sed 's/^.*output -raw my_bucket_name//' | sed 's/::debug::.*//' | tr -d '\n' | xargs)
          EKS_CLUSTER_NAME=$(terraform output -raw eks_cluster_name | sed 's/^.*output -raw eks_cluster_name//' | sed 's/::debug::.*//' | tr -d '\n' | xargs)
          ECR_REPOSITORY_URL=$(terraform output -raw ecr_repository_url | sed 's/^.*output -raw ecr_repository_url//' | sed 's/::debug::.*//' | tr -d '\n' | xargs)
          ALB_ACM_CERT_ARN=$(terraform output -raw alb_acm_certificate_arn | sed 's/^.*output -raw alb_acm_certificate_arn//' | sed 's/::debug::.*//' | tr -d '\n' | xargs)
          EC2_INSTANCE_ID=$(terraform output -raw ec2_instance_id | sed 's/^.*output -raw ec2_instance_id//' | sed 's/::debug::.*//' | tr -d '\n' | xargs)
          EC2_PUBLIC_IP=$(terraform output -raw ec2_public_ip | sed 's/^.*output -raw ec2_public_ip//' | sed 's/::debug::.*//' | tr -d '\n' | xargs)
          VPC_ID=$(terraform output -raw VPC_ID | sed 's/^.*output -raw VPC_ID//' | sed 's/::debug::.*//' | tr -d '\n' | xargs)

          echo "âœ… Exporting outputs to GITHUB_ENV..."
          {
            echo "TF_RDS_ENDPOINT<<EOF"
            echo "$RDS_ENDPOINT"
            echo "EOF"
          } >> $GITHUB_ENV

          {
            echo "TF_S3_BUCKET<<EOF"
            echo "$S3_BUCKET"
            echo "EOF"
          } >> $GITHUB_ENV

          {
            echo "TF_EKS_CLUSTER_NAME<<EOF"
            echo "$EKS_CLUSTER_NAME"
            echo "EOF"
          } >> $GITHUB_ENV

          {
            echo "TF_ECR_REPOSITORY_URL<<EOF"
            echo "$ECR_REPOSITORY_URL"
            echo "EOF"
          } >> $GITHUB_ENV

          {
            echo "TF_ALB_ACM_CERT_ARN<<EOF"
            echo "$ALB_ACM_CERT_ARN"
            echo "EOF"
          } >> $GITHUB_ENV
          {
            echo "TF_EC2_INSTANCE_ID<<EOF"
            echo "$EC2_INSTANCE_ID"
            echo "EOF"
          } >> $GITHUB_ENV
          {
            echo "TF_EC2_PUBLIC_IP<<EOF"
            echo "$EC2_PUBLIC_IP"
            echo "EOF"
          } >> $GITHUB_ENV
          {
            echo "TF_VPC_ID<<EOF"
            echo "$VPC_ID"
            echo "EOF"
          } >> $GITHUB_ENV

      # --- 3. Docker ì´ë¯¸ì§€ ë¹Œë“œ ë° í‘¸ì‹œ ---
      
      - name: Login to AWS ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build and Push Docker Image
        # ì´ì „ ë‹¨ê³„ì—ì„œ GITHUB_ENVì— ì €ì¥í•œ ë³€ìˆ˜ë¥¼ ì—¬ê¸°ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤.
        env:
          PHOTOPRISM_DATABASE_SERVER: ${{ env.TF_RDS_ENDPOINT }}
          PHOTOPRISM_S3_BUCKET: ${{ env.TF_S3_BUCKET }}
        run: |
          docker buildx build \
            --platform linux/amd64 \
            --progress plain \
            --build-arg PHOTOPRISM_DATABASE_SERVER="$PHOTOPRISM_DATABASE_SERVER" \
            --build-arg PHOTOPRISM_DATABASE_NAME="$PHOTOPRISM_DATABASE_NAME" \
            --build-arg PHOTOPRISM_DATABASE_USER="${{ secrets.PHOTOPRISM_DATABASE_USER }}" \
            --build-arg PHOTOPRISM_DATABASE_PASSWORD="${{ secrets.PHOTOPRISM_DATABASE_PASSWORD }}" \
            --build-arg PHOTOPRISM_ADMIN_PASSWORD="${{ secrets.PHOTOPRISM_ADMIN_PASSWORD }}" \
            --build-arg PHOTOPRISM_S3_BUCKET="$PHOTOPRISM_S3_BUCKET" \
            --build-arg AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
            --build-arg AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            --build-arg AWS_REGION="${{ env.AWS_REGION }}" \
            -t "$ECR_REGISTRY:latest" \
            --push .

      # --- 4. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ìƒì„± ë° EKS ë°°í¬ ---

      - name: Install required tools
        run: |
          sudo apt-get update
          sudo apt-get install -y gettext-base jq mysql-client

          # kubectl ì„¤ì¹˜
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Helm install cluster
        run: |
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update
          helm install aws-load-balancer-controller eks/aws-load-balancer-controller \
           -n kube-system \
            --set clusterName=$TF_EKS_CLUSTER_NAME \
            --set serviceAccount.create=true \
            --set serviceAccount.name=aws-load-balancer-controller \
            --set region=$AWS_REGION \
            --set vpcId=$VPC_ID

      - name: Create database in RDS
        # ì´ì „ ë‹¨ê³„ì—ì„œ GITHUB_ENVì— ì €ì¥í•œ ë³€ìˆ˜ë¥¼ ì—¬ê¸°ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤.
        env:
          RDS_ENDPOINT: ${{ env.TF_RDS_ENDPOINT }}
          DB_USER: ${{ secrets.PHOTOPRISM_DATABASE_USER }}
          DB_PASSWORD: ${{ secrets.PHOTOPRISM_DATABASE_PASSWORD }}
          DB_NAME: ${{ secrets.PHOTOPRISM_DATABASE_NAME }}
        run: |
          echo "ğŸ” RDS_ENDPOINT=$RDS_ENDPOINT"

          RDS_HOST="${RDS_ENDPOINT%%:*}"
          RDS_PORT="${RDS_ENDPOINT##*:}"

          if [ "$RDS_HOST" == "$RDS_PORT" ]; then
            echo "âš ï¸ Port not found in RDS_ENDPOINT, defaulting to 3306."
            RDS_PORT="3306"
          fi
          
          echo "ğŸ”Œ Attempting to connect to RDS host: '$RDS_HOST' on port '$RDS_PORT'..."
          
          mysql -h "$RDS_HOST" -P "$RDS_PORT" -u "$DB_USER" -p"$DB_PASSWORD" -e "SELECT 1;" --connect-timeout=15 || {
            echo "âŒ RDS connection failed."
            exit 1
          }

          echo "âœ… RDS connection successful."
          echo "ğŸ› ï¸ Creating database '$DB_NAME' if it does not exist..."
          
          mysql -h "$RDS_HOST" -P "$RDS_PORT" -u "$DB_USER" -p"$DB_PASSWORD" \
                -e "CREATE DATABASE IF NOT EXISTS \`$DB_NAME\`;"

          echo "âœ… Database creation command sent."

      - name: Terraform Apply (Private RDS)
        working-directory: terraform
        run: terraform apply -var-file="terraform.tfvars" -var="rds_publicly_accessible=false" -auto-approve -input=false

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ secrets.AWS_REGION }} \
            --name ${{ env.TF_EKS_CLUSTER_NAME }}

      - name: Render and Deploy ConfigMap and Secret
        env:
          TF_RDS_ENDPOINT: ${{ env.TF_RDS_ENDPOINT }}
          TF_S3_BUCKET: ${{ env.TF_S3_BUCKET }}
          TF_ALB_ACM_CERT_ARN: ${{ env.TF_ALB_ACM_CERT_ARN }}
          PHOTOPRISM_DATABASE_USER: ${{ secrets.PHOTOPRISM_DATABASE_USER }}
          PHOTOPRISM_DATABASE_PASSWORD: ${{ secrets.PHOTOPRISM_DATABASE_PASSWORD }}
          PHOTOPRISM_ADMIN_PASSWORD: ${{ secrets.PHOTOPRISM_ADMIN_PASSWORD }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          ECR_REPOSITORY_URI: ${{ secrets.ECR_REPOSITORY_URI }}
        run: |
          echo "ğŸ”§ ConfigMap í™˜ê²½ë³€ìˆ˜ ì¹˜í™˜"
          envsubst < k8s/configmap.yml > k8s/configmap.rendered.yml
          
          echo "ğŸ” Secret í™˜ê²½ë³€ìˆ˜ ì¹˜í™˜"
          envsubst < k8s/secret.yml > k8s/secret.rendered.yml

          echo "ğŸ“¦ Deployment í™˜ê²½ë³€ìˆ˜ ì¹˜í™˜"
          envsubst < k8s/deployment.yml > k8s/deployment.rendered.yml
          
        #echo "ğŸŒ Ingress ë Œë”ë§"
        #envsubst < k8s/ingress.yml > k8s/ingress.rendered.yml

          echo "ğŸš€ Kubernetesì— ì ìš©"
          kubectl apply -f k8s/configmap.rendered.yml
          kubectl apply -f k8s/secret.rendered.yml
          kubectl apply -f k8s/deployment.rendered.yml
          kubectl apply -f k8s/service.yml
        #kubectl apply -f k8s/ingress.rendered.yml

          echo "â³ ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
          kubectl rollout status deployment/photoprism --timeout=90s

      - name: Debug if deployment fails
        if: failure()
        run: |
          echo "âŒ ë°°í¬ ì‹¤íŒ¨! ë””ë²„ê¹… ì‹œì‘"
          kubectl get all
          kubectl describe deployment photoprism
          kubectl logs deployment/photoprism || true
          kubectl get events --sort-by=.metadata.creationTimestamp
